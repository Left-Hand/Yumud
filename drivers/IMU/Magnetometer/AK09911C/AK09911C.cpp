#include "AK09911C.hpp"


#define DEBUG_EN

#ifdef DEBUG_EN

#define CHECK_RES(x, ...) ({\
    const auto __res_check_res = (x);\
    if(x.is_err()) DEBUG_SRC{__VA_ARGS__};\
    __res_check_res;\
})\


#define CHECK_ERR(x, ...) ({\
    const auto && __err_check_err = (x);\
    DEBUG_SRC{#x, ##__VA_ARGS__};\
    __err_check_err;\
})\

#else
#define CHECK_RES(x, ...) (x)
#define CHECK_ERR(x, ...) (x)
#endif


using namespace ymd;
using namespace ymd::drivers;

using Error = ImuError;

template<typename T = void>
using IResult = Result<T, Error>;

template<typename Fn, typename Fn_Dur>
__inline Result<void, Error> retry(const size_t times, Fn && fn, Fn_Dur && fn_dur){
    if constexpr(!std::is_null_pointer_v<Fn_Dur>) std::forward<Fn_Dur>(fn_dur)();
    Result<void, Error> res = std::forward<Fn>(fn)();
    if(res.is_ok()) return Ok();
    if(!times) return res;
    else return retry(times - 1, std::forward<Fn>(fn), std::forward<Fn_Dur>(fn_dur));
}


template<typename Fn>
__inline Result<void, Error> retry(const size_t times, Fn && fn){
    return retry(times, std::forward<Fn>(fn), nullptr);
}

IResult<> AK09911C::init(){
    if(const auto res = validate(); 
        res.is_err()) return res;

    if(const auto res = set_mode(Mode::Cont4);
        res.is_err()) return res;
    return Ok();
}


IResult<> AK09911C::update(){
    if(const auto res = read_burst(
        MagXReg::address, std::span(&mag_x_reg.as_ref(), 3));
        res.is_err()) return res;
    if(const auto res = read_reg(st2_reg);
        res.is_err()) return res;

    if(st2_reg.hofl) return CHECK_ERR(Err(Error::MagOverflow));

    return Ok();
}


IResult<Vector3<int8_t>> AK09911C::get_coeff(){
    if(const auto res = write_reg(0x0a, 0x0f);
        res.is_err()) return Err(res.unwrap_err());
    if(const auto res = read_reg(asax_reg.address, asax_reg.as_ref());
        res.is_err()) return Err(res.unwrap_err());
    if(const auto res = read_reg(asay_reg.address, asay_reg.as_ref());
        res.is_err()) return Err(res.unwrap_err());
    if(const auto res = read_reg(asaz_reg.address, asaz_reg.as_ref());
        res.is_err()) return Err(res.unwrap_err());
    
    return Ok(Vector3<uint8_t>{
        asax_reg.data, 
        asay_reg.data, 
        asaz_reg.data
    });
}
IResult<> AK09911C::blocking_update(){
    static constexpr auto READ_TIMEOUT_MS = 10ms;
    const auto begin_u = clock::millis();

    while(clock::millis() - begin_u < READ_TIMEOUT_MS) {
        if(const auto res = is_data_ready(); res.is_ok()){
            if(res.unwrap() == true) break;
        }else {
            return CHECK_ERR(Err(res.unwrap_err()));
        }
        clock::delay(100us);
    }

    if(const auto res = read_burst(MagXReg::address, std::span(&mag_x_reg.as_ref(), 3));
        res.is_err()) return res;
    if(const auto res = read_reg(st2_reg);
        res.is_err()) return res;

    if(st2_reg.hofl) return CHECK_ERR(Err(Error::MagOverflow));

    return Ok();
}
IResult<> AK09911C::selftest(){
    // 6.4.4. Self-test Mode
    // Self-test mode is used to check if the magnetic sensor is working normally.
    // When Self-test mode (MODE[4:0]=“10000”) is set, magnetic field is generated by the internal magnetic source and 
    // magnetic sensor is measured. Measurement data is stored to measurement data registers (HXL to HZH), then AK09911
    // transits to Power-down mode automatically.
    // Data read sequence and functions of read-only registers in Self-test mode is the same as Single measurement mode.

    // 6.4.4.1. Self-test Sequence
    // (1) Set Power-down mode. (MODE[4:0]=“00000”)
    // (2) Set Self-test mode. (MODE[4:0]=“10000”)
    // (3) Check Data Ready or not by polling DRDY bit of ST1 register
    // When Data Ready, proceed to the next step.
    // (4) Read measurement data (HXL to HZH)

    if(const auto res = set_mode(Mode::PowerDown);
        res.is_err()) return res;
    clock::delay(1ms);
    if(const auto res = set_mode(Mode::SelfTest);
        res.is_err()) return res;
    clock::delay(1ms);

    //进行两次测量 因为第一次的数据不准容易自检失败
    for(size_t i = 0; i < 2; ++i){
        if(const auto res = retry(2, [this]{return blocking_update();});
            res.is_err()) return res;

        clock::delay(2ms);
    }

    auto check_xyz = [this] -> IResult<>{
        // 6.4.4.2. Self-test Judgment
        // When measurement data read by the above sequence is in the range of following 
        // table after sensitivity adjustment (refer to 8.3.11), AK09911 is working normally.
        // HX[15:0] HY[15:0] HZ[15:0]
        // Criteria -30 ≤ HX ≤ +30 -30 ≤ HY ≤ +30 -400 ≤ HZ ≤ -50


        const auto x = mag_x_reg.as_val();
        const auto y = mag_y_reg.as_val();
        const auto z = mag_z_reg.as_val();

        if(not IN_RANGE(x, -30, 30)) return CHECK_ERR(Err(Error::AxisXOverflow), x,);
        if(not IN_RANGE(y, -30, 30)) return CHECK_ERR(Err(Error::AxisYOverflow), y);
        if(not IN_RANGE(z, -400, 50)) return CHECK_ERR(Err(Error::AxisZOverflow), z);

        return Ok();
    };

    if(const auto res = retry(3, [&]{return check_xyz();}, []{clock::delay(2ms);});
        res.is_err()) return res;

    return Ok();
}

IResult<> AK09911C::validate(){
    auto check_vendor = [&] -> IResult<> {
        if(const auto res = read_reg(wia1_reg) | read_reg(wia2_reg);
            res.is_err()) return CHECK_RES(
                res, 
                "failed to read reg when validate, check RSTN pin is HIGH",
                "error is", res.unwrap_err().as<hal::HalError>().unwrap());

        if(wia1_reg.as_val() != wia1_reg.KEY) return CHECK_ERR(Err(Error::WrongCompanyId),  
            "wrong company id, correct is", wia1_reg.KEY, "but read is", wia1_reg.as_val());

        if(wia2_reg.as_val() != wia2_reg.KEY) return CHECK_ERR(Err(Error::WrongDeviceId), 
            "wrong device id, correct is", wia2_reg.KEY, "but read is", wia2_reg.as_val());

        return Ok();
    };

    if(const auto res = retry(2, [&]{return check_vendor();}, []{clock::delay(2ms);});
        res.is_err()) return res;

    if(const auto res = selftest(); res.is_err())
        return res;
    return Ok();
}

IResult<bool> AK09911C::is_data_ready(){
    if(const auto res = read_reg(st1_reg); 
        res.is_err()) return Err(res.unwrap_err());

    return Ok(st1_reg.is_data_ready());
}

IResult<bool> AK09911C::is_data_overrun(){
    if(const auto res = read_reg(st1_reg); 
        res.is_err()) return Err(res.unwrap_err());

    return Ok(st1_reg.is_data_overrun());
}

IResult<> AK09911C::enable_hs_i2c(const Enable en){
    st1_reg.hsm = (en == EN) ? 1 : 0;
    return write_reg(st1_reg);
}

IResult<> AK09911C::set_mode(const Mode mode){
    cntl2_reg.mode = mode;
    return write_reg(cntl2_reg);
}

IResult<> AK09911C::reset(){
    cntl3_reg.srst = 1;
    const auto res = write_reg(cntl3_reg);
    cntl3_reg.srst = 0;
    return res;
}

IResult<> AK09911C::set_odr(const Odr odr){
    return set_mode(static_cast<Mode>(odr));
}

IResult<Vector3<q24>> AK09911C::read_mag(){
    static constexpr int16_t MIN_VALUE = -8190;
    static constexpr int16_t MAX_VALUE = 8190;

    const auto x = mag_x_reg.as_val();
    const auto y = mag_y_reg.as_val();
    const auto z = mag_z_reg.as_val();

    if(not IN_RANGE(x, MIN_VALUE, MAX_VALUE)) 
        return CHECK_ERR(Err(Error::AxisXOverflow));

    if(not IN_RANGE(y, MIN_VALUE, MAX_VALUE))
        return CHECK_ERR(Err(Error::AxisYOverflow));
    
    if(not IN_RANGE(z, MIN_VALUE, MAX_VALUE))
        return CHECK_ERR(Err(Error::AxisZOverflow));
    
    static constexpr q24 VALUE_LSB = q24(6E-5);
    return Ok(Vector3<q24>{
        VALUE_LSB * x,
        VALUE_LSB * y,
        VALUE_LSB * z
    });
}